Bicycle viewer with different camera modes and controls

author: Brendan Chong
TOTAL TIME: 4 hours

Perspective keybinds:
M/m - Cycle through camera modes. 0 = Orthographic, 1 = Perspective, 2 = First Person
R/r - Reset the state to the initial view (orthographic, zoom=-3.6, th = 45, ph = 20)
WASD - Move forward, left, backward, right in first person mode
W - Zooms in and out in orthographic mode
Arrow keys - Change view angles in all modes
Click + drag - Change view angles in all modes

Other notes about the perspective:
- In first person, the camera position is limited to be within the white plane that is the world bounds. If the camera is positioned along a bound, you can still move tangentially or away from the bound, but not through it.
- Since you are limited to the white plane bounds, your camera position must be clipped into it the domain when switching. This is done naively by clamping the x and z coordinates. This could be improved by using the clipping algorithm to find the clipping point in the domain and making this the new camera position.
- When switching into first person, the camera will always face towards the origin, as is the case for the orthographic and perspective modes.

- The bikes can be repositioned, reoriented, and rescaled, but there's no keybind for this as of now. I just threw in a couple different positions to demonstrate this. 
- The position of the bike seems to be backward from what is specified. That is, if you create a bike at (x,y) = (1.0, 1.0), the bike will be created down and to the left of (0,0). I thought I fixed this by doing the reverse transform of what is specified, but this did not seem to fix the issue. Perhaps I need to remove the negative sign from this transformation after all
- The coloring is done in each function, so the each part of the bike will always have the same color scheme. However, this is only the case since the parts are being used in the same assembly each time. For example, if you made a different torus with different transformations, the color would be different. The only way I thought of to fix this and color based on true global coordinate would require knowing the entire transformation matrix and backing out the inverse to determine the global coordinates. Perhaps there is a way to do this, but since the color wasn't part of the main assignment I didn't bother.

USE OF AI:
I used AI to help with the coloring method. Once it gave me the idea to do the global mapping, I implemented it everywhere else in the code. Otherwise, I use Copilot and regularly use it to complete lines after reviewing the proposed changes. The composition of the bike parts was done entirely without the use of AI, and would likely have been faster without it trying to backseat code for me.
AI was also used to implement the mouse control feature. 